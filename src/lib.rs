//! Bloggo is a static site generator, in the spirit of [Jekyll](https://jekyllrb.com)
//! and [Hugo](https://gohugo.io). It allows an author to write articles in
//! [Markdown](https://commonmark.org) and provide [Handlebars](https://handlebarsjs.com)
//! templates that are used to render the posts to HTML files. It also copies
//! other static content such as images and CSS stylesheets to the destination
//! directory, which can then be served by any web server that can serve files
//! from the filesystem.
//!
//! # Usage
//!
//! Most users will use the `bloggo` binary, rather than using the library directly.
//!
//! ```text
//! Usage: bloggo [OPTIONS] <COMMAND>
//!
//! Commands:
//!   clean  Clean destination directory
//!   build  Build static site pages
//!   help   Print this message or the help of the given subcommand(s)
//!
//! Options:
//!   -s, --source <DIR>  Directory containing post and template source [default: source/]
//!   -o, --dest <DIR>    Directory where output will be stored [default: build/]
//!   -b, --base <URL>    The base URL for relative links [default: ]
//!   -v, --verbose       Provide verbose output
//!   -h, --help          Print help
//!   -V, --version       Print version
//! ```
//!
//! The layout of the source directory should appear as:
//! ```text
//! src
//! |-- assets
//! |   |-- style.css
//! |   |-- images
//! |   |   |-- example.jpg
//! |   |   |-- example.png
//! |-- templates
//! |   |-- index.html.hbs
//! |   |-- post.html.hbs
//! |-- posts
//!     |-- 2023-03-01_an_example_post.md
//!     |-- 2023-03-02_another_post.md
//! ```
//!
//! The `assets` directory is copied as-is to the destination directory. A file
//! `assets/style.css` will copied to the build directory as `style.css`, and
//! `assets/images/example.jpg` will be copied to `images/example.jpg`.
//!
//! The `posts` directory contains the Markdown files for each post. The build
//! phase of Bloggo will parse each post, and render an HTML file in the
//! destination using a template. The source file is similar to other static site
//! generators: it includes a "front matter" block, delimited to describe the
//! format of the front matter (three hyphens for YAML), followed by the Markdown
//! content. The front matter properties are passed into the template renderer,
//! and some of the properties are special:
//!
//! - `date`: If present, this is used as the `date` property in the Handlebars
//!   template. The expected format is the date and time format specified by
//!   [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations).
//!   If not present, Bloggo will attempt to guess based on the name
//!   of the file: a file named `2023-04-05_example.md` will have a `date` property
//!   of `2023-04-05T00:00:00Z`.
//! - `layout`: The name of the template used to render this post. The name of the
//!   layout must refer to a file that appears in the `templates` directory with
//!   the filename extension of `.html.hbs`. The default value is `post`.
//! - `tags`: An array of strings. Bloggo generates an index and feed for each
//!   tag in the site.
//! - `abstract`: If not present, Bloggo will populate this property with the
//!   first paragraph that appears in the Markdown source.
//! - `path`: The path of the generated HTML file in the build directory. This
//!   property is generated by Bloggo.
//! - `url`: This is the URL of the post, formed by concatenating the base url
//!   with the `path`. This property is generated by Bloggo.
//!
//! The `templates` directory contains the Handlebars templates used to render
//! posts. The following two template files are required; additional template
//! files can be used and specified by using the `layout` property of each post,
//! and can also be included into other templates using the Handlebars
//! `{{> ... }}` directive.
//!
//! - `index.html.hbs`: Used to render the site and tag indexes.
//! - `post.html.hbs`: The default template for individual post pages.
//!
//! The object passed into the Handlebars renderer includes the properties:
//! - `posts`: An array of Post objects to render. In the site index, this contains
//!   all of the posts in the sites. In each tag index, this contains the posts
//!   that have the tag. In individual posts, this array will contain the single
//!   post to render. Each post object contains the properties specified in the
//!   front matter.
//! - `tags`: An array of Tag objects used in the site. Each Tag object has the
//!   properties:
//!   - `name`: the name of the tag.
//!   - `count`: the number of posts with the tag.
//!   - `index_url`: The url of the index page for the tag.
//! - `tag`: The tag of the posts in the `posts` array, present when the tag index
//!   is being rendered.
//!
//! When the `bloggo build` command is used with the source directory described
//! above, the destination directory will contain
//!
//! ```text
//! build
//! |-- index.html
//! |-- atom.xml
//! |-- 2023-03-01_an_example_post.html
//! |-- 2023-03-02_another_post.html
//! |-- tag-1
//! |   |-- index.html
//! |   |-- atom.xml
//! |-- tag-2
//! |   |-- index.html
//! |   |-- atom.xml
//! |-- style.css
//! |-- images
//!     |-- example.jpg
//!     |-- example.png
//! ```
//!
//! This directory can be copied to a web server that can serve static files.
//!
//! # Acknowledgements
//!
//! Bloggo depends on a number of open source projects.
//!
//! - [chrono](https://crates.io/crates/chrono)
//! - [clap](https://crates.io/crates/clap)
//! - [env_logger](https://crates.io/crates/env_logger)
//! - [handlebars](https://crates.io/crates/handlebars)
//! - [log](https://crates.io/crates/log)
//! - [pulldown-cmark](https://crates.io/crates/pulldown-cmark)
//! - [serde](https://crates.io/crates/serde)
//! - [serde_json](https://crates.io/crates/serde_json)
//! - [serde_yaml](https://crates.io/crates/serde_yaml)
//! - [toml](https://crates.io/crates/toml)
//!
//! # License
//!
//! Bloggo is distributed under the terms of the MIT License.

pub mod error;
pub mod fs;
pub mod helper;
pub mod value;

use chrono::{DateTime, NaiveDate, Utc};
use error::Error;
use handlebars::{DirectorySourceOptions, Handlebars};
use helper::{FormatDateTimeHelper, JoinHelper};
use log::{debug, info};
use pulldown_cmark::{html, Options, Parser};
use serde::{ser::SerializeMap, Serialize, Serializer};
use std::{
    borrow::Borrow,
    collections::HashMap,
    fs::File,
    io::{BufRead, BufReader, BufWriter, Read, Write},
    path::{Path, PathBuf},
};
use value::Value;

/// A Result type whose [Err] contains a Bloggo [Error].
pub type Result<T> = std::result::Result<T, Error>;

/// A Post is a mapping of [String]s to [Value]s.
type Post = HashMap<String, Value>;

/// An instance of Bloggo that contains configuration settings and stateful
/// context for rendering posts.
///
/// Use [Builder] to create a new instance.
///
/// # Examples
///
/// ```no_run
/// use bloggo::Builder;
///
/// let mut bloggo = Builder::new()
///     .src_dir("source")
///     .dest_dir("destination")
///     .build();
///
/// bloggo.clean();
/// bloggo.build();
/// ```
pub struct Bloggo<'a> {
    src_dir: String,
    dest_dir: String,
    base_url: String,
    handlebars: Handlebars<'a>,
}

impl<'a> Bloggo<'a> {
    /// Create a new Bloggo instance with the given source and destination
    /// directories.
    pub fn new(src_dir: String, dest_dir: String, base_url: String) -> Self {
        let mut handlebars = Handlebars::new();
        handlebars.register_helper("formatDateTime", Box::new(FormatDateTimeHelper::new()));
        handlebars.register_helper("join", Box::new(JoinHelper::new()));
        Self {
            src_dir,
            dest_dir,
            base_url,
            handlebars,
        }
    }

    /// Removes the destination directory.
    pub fn clean(&self) -> Result<()> {
        info!("Cleaning build directory: {}", self.dest_dir);
        fs::remove_dir_all(&self.dest_dir).map_err(|e| e.into())
    }

    /// Builds the static site by copying assets and generating HTML.
    pub fn build(&mut self) -> Result<()> {
        info!("Building from {} to {}", self.src_dir, self.dest_dir);

        let mut template_dir = PathBuf::new();
        template_dir.push(&self.src_dir);
        template_dir.push("templates");
        info!(
            "Registering templates in directory {}",
            template_dir.display()
        );

        let html_options = DirectorySourceOptions {
            tpl_extension: ".html.hbs".into(),
            ..DirectorySourceOptions::default()
        };
        self.handlebars
            .register_templates_directory(&template_dir, html_options)?;

        let xml_options = DirectorySourceOptions {
            tpl_extension: ".xml.hbs".into(),
            ..DirectorySourceOptions::default()
        };
        self.handlebars
            .register_templates_directory(&template_dir, xml_options)?;

        fs::create_dir_all(&self.dest_dir)?;
        self.copy_assets()?;
        let all_posts = self.parse_posts()?;

        // Generate tag indices.
        let tag_index = self.generate_tag_indexes(&all_posts);
        let tags: Vec<Tag> = tag_index
            .iter()
            .map(|entry| Tag {
                name: entry.0,
                index_url: format!("{}/{}/", self.base_url, entry.0),
                count: entry.1.len(),
            })
            .collect();

        let all_posts_refs: Vec<&Post> = all_posts.iter().collect();
        let mut render_context = RenderContext {
            tag: None,
            tags: &tags,
            posts: &all_posts_refs,
        };

        self.render_index(&render_context, &PathBuf::from("index.html"))?;
        self.render_atom_feed(&render_context, &PathBuf::from("atom.xml"))?;
        for (tag, posts) in &tag_index {
            let mut index_path = PathBuf::from(tag);
            index_path.push("index.html");
            render_context.tag = Some(tag);
            render_context.posts = posts;
            self.render_index(&render_context, &index_path)?;

            let mut feed_path = PathBuf::from(tag);
            feed_path.push("atom.xml");
            self.render_atom_feed(&render_context, &feed_path)?;
        }
        self.render_posts(&all_posts, &tags)?;
        Ok(())
    }

    fn render_index(&self, render_context: &RenderContext, path: &Path) -> Result<()> {
        let mut p = PathBuf::new();
        p.push(&self.dest_dir);
        p.push(path);
        info!("Rendering index to {}", p.display());
        if let Some(parent) = p.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut out = BufWriter::new(File::create(p)?);
        self.generate_index(render_context, &mut out)?;
        out.flush()?;
        Ok(())
    }

    fn render_atom_feed(&self, render_context: &RenderContext, path: &Path) -> Result<()> {
        let mut p = PathBuf::new();
        p.push(&self.dest_dir);
        p.push(path);
        info!("Rendering feed to {}", p.display());
        if let Some(parent) = p.parent() {
            fs::create_dir_all(parent)?;
        }
        let mut out = BufWriter::new(File::create(p)?);
        self.generate_atom_feed(render_context, &mut out)?;
        out.flush()?;
        Ok(())
    }

    /// Copy all files from the "assets/" source directory to the
    /// destination directory.
    fn copy_assets(&self) -> Result<usize> {
        fn is_hidden(path: &Path) -> bool {
            path.file_name()
                .and_then(|os| os.to_str())
                .map(|s| s.starts_with('.'))
                .unwrap_or(false)
        }

        let mut count = 0_usize;

        let mut src_dir = PathBuf::new();
        src_dir.push(&self.src_dir);
        src_dir.push("assets");

        for rde in fs::recursive_read_dir(&src_dir)? {
            let de = rde?;
            let src_path = de.path();
            if !is_hidden(&src_path) {
                let mut dest_path = PathBuf::new();
                dest_path.push(&self.dest_dir);
                dest_path.push(src_path.strip_prefix(&src_dir)?);

                if src_path.is_dir() {
                    info!("Creating directory {}", dest_path.display());
                    fs::create_dir_all(dest_path)?;
                } else {
                    info!("Copying {} to {}", src_path.display(), dest_path.display());
                    std::fs::copy(src_path, dest_path)?;
                    count += 1;
                }
            }
        }
        Ok(count)
    }

    /// Render the posts in the source directory to the destination directory.
    fn render_posts(&self, posts: &Vec<Post>, tags: &Vec<Tag>) -> Result<()> {
        for post in posts {
            self.render_post(post, tags)?;
        }

        Ok(())
    }

    /// Render an individual post to the destination directory.
    fn render_post(&self, post: &Post, tags: &Vec<Tag>) -> Result<()> {
        let template = post
            .get("layout")
            .and_then(|v| v.as_string())
            .unwrap_or_else(|| String::from("default"));
        if let Some(Value::String(filename)) = post.get("path") {
            let mut pathbuf = PathBuf::new();
            pathbuf.push(&self.dest_dir);
            pathbuf.push(filename);
            pathbuf.set_extension("html");
            let out = File::create(&pathbuf)?;
            info!("Rendering post to {}", pathbuf.display());
            let render_context = RenderContext {
                tag: None,
                posts: &vec![post],
                tags,
            };
            self.handlebars
                .render_to_write(&template, &render_context, out)?;
        }
        Ok(())
    }

    /// Generate an index page using the index template and the list of posts.
    fn generate_index<W>(&self, render_context: &RenderContext, out: &mut W) -> Result<()>
    where
        W: Write,
    {
        self.handlebars
            .render_to_write("index", render_context, out)?;
        Ok(())
    }

    /// Generate an Atom feed using the atom template and the list of posts.
    fn generate_atom_feed<W>(&self, render_context: &RenderContext, out: &mut W) -> Result<()>
    where
        W: Write,
    {
        self.handlebars
            .render_to_write("atom", render_context, out)?;
        Ok(())
    }

    fn generate_tag_indexes<'b>(&'b self, posts: &'b Vec<Post>) -> HashMap<String, Vec<&'b Post>> {
        let mut tag_index: HashMap<String, Vec<&Post>> = HashMap::new();

        let mut add_post_to_index = |s: &String, p| {
            if let Some(v) = tag_index.get_mut(s) {
                v.push(p);
            } else {
                let v = vec![p];
                tag_index.insert(s.clone(), v);
            }
        };

        // generate index structure
        for post in posts {
            match post.get("tags") {
                Some(Value::String(s)) => {
                    add_post_to_index(s, post);
                }
                Some(Value::Array(a)) => {
                    for element in a {
                        if let Some(s) = element.as_string() {
                            add_post_to_index(&s, post)
                        }
                    }
                }
                _ => {}
            }
        }
        tag_index
    }

    /// Parse the posts in the source directory.
    fn parse_posts(&self) -> Result<Vec<Post>> {
        let mut posts = Vec::new();
        let mut src_dir = PathBuf::new();
        src_dir.push(&self.src_dir);
        src_dir.push("posts");

        for rde in fs::recursive_read_dir(&src_dir)? {
            let de = rde?;
            let src_path = de.path();
            posts.push(self.parse_post(src_path)?);
        }
        posts.sort_by_cached_key(|p| {
            p.get("date")
                .and_then(|v| v.as_string())
                .and_then(|s| DateTime::parse_from_str(&s, "%+").ok())
                .unwrap_or_else(|| DateTime::parse_from_str("1970-01-01T00:00:00Z", "%+").unwrap())
            // TODO: Make the Unix Epoch a constant so it doesn't need to be
            // parsed each time.
        });
        posts.reverse();
        Ok(posts)
    }

    /// Parse a post from the given [Path].
    fn parse_post<P>(&self, path: P) -> Result<Post>
    where
        P: AsRef<Path>,
    {
        // open a file
        // read first line
        let p = path.as_ref();
        debug!("parse_post: Parsing {}", p.display());
        let file = File::open(p)?;
        let mut line = String::with_capacity(256);
        let mut buf = BufReader::new(file);
        if buf.read_line(&mut line)? == 0 {
            return Err(Error::UnexpectedEOF(p.as_os_str().to_os_string()));
        }
        let mut post = if line.starts_with("---") {
            debug!("parse_post: Parsing YAML front matter.");
            let front_matter = read_until(&mut buf, "---")?;
            if let Value::Map(map) = parse_yaml_data(front_matter.as_str())? {
                Ok(map)
            } else {
                Err(Error::Other("Parsed YAML is not a mapping.".to_string()))
            }
        } else {
            Err(Error::Other("Missing front matter.".to_string()))
        }?;
        let mut rest_of_file = String::new();
        buf.read_to_string(&mut rest_of_file)?;

        let mut text = String::with_capacity(rest_of_file.len());
        if p.extension().and_then(|s| s.to_str()) == Some("md") {
            let mut options = Options::all();
            options.remove(Options::ENABLE_SMART_PUNCTUATION);
            let parser = Parser::new_ext(&rest_of_file, options);
            html::push_html(&mut text, parser);
        } else {
            text = rest_of_file;
        }
        if !post.contains_key("abstract") {
            if let Some(p) = extract_first_paragraph(&text) {
                post.insert("abstract".into(), p.into());
            }
        }

        // Replace a tags String with a single element tags Array
        if let Some(Value::String(_)) = post.get("tags") {
            if let Some(Value::String(s)) = post.remove("tags") {
                post.insert("tags".into(), Value::Array(vec![Value::String(s)]));
            }
        }

        post.insert("text".into(), text.into());

        let mut dest_path_buf = p
            .strip_prefix(&self.src_dir)?
            .strip_prefix("posts")?
            .to_path_buf();
        dest_path_buf.set_extension("html");

        let cows = dest_path_buf.to_string_lossy();
        let filename: &str = cows.borrow();
        post.insert("path".into(), filename.into());

        let mut url = String::from(&self.base_url);
        url.push('/');
        url.push_str(filename);
        post.insert("url".into(), url.into());
        if !post.contains_key("date") {
            if let Some(date) = extract_date_from_str(filename) {
                let formatted = format!("{}", date.format("%+"));
                post.insert("date".into(), formatted.into());
            }
        }
        Ok(post)
    }
}

/// Find the content between `<p>` and `</p>`, if it exists.
///
///# Example
///
/// ```compile_fail
/// use bloggo::extract_first_paragraph;
///
/// assert_eq!(
///     "<p>foo bar</p>",
///     extract_first_paragraph("blah <p>foo bar</p> blah").unwrap());
///
/// assert_eq!(None, extract_first_paragraph("blah blah blah"));
/// ```
fn extract_first_paragraph(text: &str) -> Option<String> {
    text.find("<p>").and_then(|begin| {
        text.find("</p>")
            .map(|end| String::from(&text[begin..(end + 4)]))
    })
}

/// Attempt to extract a date from the first ten characters of a string,
/// if it is formatted as YYYY-mm-dd.
///
/// The date will have a time of midnight, UTC
///
///# Example
/// ```compile_fail
/// use bloggo::extract_date_from_str;
///
/// assert_eq!(
///     "2023-02-26T00:00:00Z".parse::<DateTime<Utc>>().ok(),
///     extract_date_from_str("2023-02-26-blah blah blah")
/// );
/// ```
fn extract_date_from_str(s: &str) -> Option<DateTime<Utc>> {
    let mut truncated = String::from(s);
    truncated.truncate(10);
    NaiveDate::parse_from_str(truncated.as_str(), "%Y-%m-%d")
        .ok()
        .and_then(|d| d.and_hms_opt(0, 0, 0))
        .map(|dt| DateTime::from_naive_utc_and_offset(dt, Utc))
}

/// Parse a YAML [str] into a [Value].
fn parse_yaml_data(yaml: &str) -> Result<Value> {
    let yval = serde_yaml::from_str::<serde_yaml::value::Value>(yaml)
        .map_err(|e| Error::Other(format!("YAML deserialization failure: {}", e)))?;
    yval.try_into()
}

/// Read a [BufRead] into a [String] until a linke with the given prefix
///
///# Example
///
/// ```compile_fail
/// use std::io::BufReader;
/// use bloggo::read_until;
///
/// let mut bufread = BufReader::new("Line One\nLine Two\n-----\nLine Three".as_bytes());
///
/// let two_lines = read_until(&mut bufread, "---");
/// assert_eq!("Line One\nLine Two\n", two_lines.unwrap());
/// ```
fn read_until<B>(buf_read: &mut B, prefix: &str) -> Result<String>
where
    B: std::io::BufRead,
{
    let mut s = String::new();
    let mut line = String::new();

    loop {
        let bytes_read = buf_read.read_line(&mut line)?;
        if bytes_read == 0 {
            return Err(Error::Other("Unexpected end of file.".to_string()));
        } else if line.starts_with(prefix) {
            return Ok(s);
        } else {
            s.push_str(line.as_str());
        }
        line.clear();
    }
}

/// A builder for Bloggo instances.
///
/// # Examples
///
/// ```
/// use bloggo::Builder;
///
/// let bloggo = Builder::new()
///     .src_dir("source")
///     .dest_dir("destination")
///     .build();
/// ```
pub struct Builder {
    src_dir: String,
    dest_dir: String,
    base_url: String,
}

impl Builder {
    /// Create a new Builder with the default source and destination
    /// directories.
    pub fn new() -> Self {
        Self {
            src_dir: String::from("src/"),
            dest_dir: String::from("dest/"),
            base_url: String::from(""),
        }
    }

    /// Set the source directory for Bloggo.
    pub fn src_dir(mut self, src_dir: impl Into<String>) -> Self {
        self.src_dir = src_dir.into();
        self
    }

    /// Set the destination directory for Bloggo.
    pub fn dest_dir(mut self, dest_dir: impl Into<String>) -> Self {
        self.dest_dir = dest_dir.into();
        self
    }

    pub fn base_url(mut self, base_url: impl Into<String>) -> Self {
        self.base_url = base_url.into();
        self
    }

    /// Build a Bloggo struct with the previously configured values.
    pub fn build<'a>(self) -> Bloggo<'a> {
        Bloggo::new(self.src_dir, self.dest_dir, self.base_url)
    }
}

impl Default for Builder {
    fn default() -> Self {
        Self::new()
    }
}

/// Struct that holds information about a single tag.
struct Tag<'a> {
    name: &'a str,
    index_url: String,
    count: usize,
}

impl<'a> Serialize for Tag<'a> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_map(Some(3))?;
        s.serialize_entry("name", self.name)?;
        s.serialize_entry("index_url", &self.index_url)?;
        s.serialize_entry("count", &self.count)?;
        s.end()
    }
}

/// Structure to hold the data values rendered by Handlebars
struct RenderContext<'a> {
    tag: Option<&'a str>,
    tags: &'a Vec<Tag<'a>>,
    posts: &'a Vec<&'a Post>,
}

impl<'a> Serialize for RenderContext<'a> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let len: usize = 2 + usize::from(self.tag.is_some());
        let mut s = serializer.serialize_map(Some(len))?;
        self.tag.map(|t| s.serialize_entry("tag", t));
        s.serialize_entry("tags", self.tags)?;
        s.serialize_entry("posts", self.posts)?;
        s.end()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn extract_first_paragraph_happy_path() {
        assert_eq!(
            "<p>foo bar</p>",
            extract_first_paragraph("blah <p>foo bar</p><p>yada yada</p> blah").unwrap()
        );
    }

    #[test]
    fn extract_first_paragraph_not_there() {
        assert_eq!(None, extract_first_paragraph("blah blah blah"));
    }

    #[test]
    fn extract_first_paragraph_zero_length() {
        assert_eq!(None, extract_first_paragraph(""));
    }

    #[test]
    fn extract_first_paragraph_missing_end_tag() {
        assert_eq!(None, extract_first_paragraph("blah <p>foo bar"));
    }

    #[test]
    fn extract_date_from_str_happy_path() {
        assert_eq!(
            "2023-02-26T00:00:00Z".parse::<DateTime<Utc>>().ok(),
            extract_date_from_str("2023-02-26-blah blah blah")
        );
    }

    #[test]
    fn extract_date_from_str_unhappy_path() {
        assert_eq!(None, extract_date_from_str("This is not a date."));
    }

    #[test]
    fn read_until_happy_path() {
        let mut bufread = BufReader::new("Line One\nLine Two\n-----\nLine Three".as_bytes());

        let two_lines = read_until(&mut bufread, "---");
        assert_eq!("Line One\nLine Two\n", two_lines.unwrap());
    }
}
